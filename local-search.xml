<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Flutter项目更新SDK</title>
    <link href="/2023/11/02/Flutter%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7SDK/"/>
    <url>/2023/11/02/Flutter%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7SDK/</url>
    
    <content type="html"><![CDATA[<p>最近把项目的SDK更新了，记录一下。我使用的是fvm作为版本管理。</p><ol><li>首先要去官网查询最新的版本列表以及Flutter和Dart对应关系。<br><a href="https://flutter.cn/docs/development/tools/sdk/releases">点击查看Flutter SDK 版本列表</a></li><li>使用<code>fvm install (flutter版本号)</code></li><li>使用<code>fvm list</code>查看SDK列表</li><li>使用Android Studio打开项目，使用<code>fvm use (flutter版本号)</code></li><li>打开<code>pubspec.yaml</code>，更新下面的代码</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">environment:<br>     sdk: <span class="hljs-string">&quot;&gt;=3.0.5 &lt;4.0.0&quot;</span><br>     <span class="hljs-comment">//这里是Dart 的版本号</span><br></code></pre></td></tr></table></figure><ol start="6"><li>在<code>Android Studio</code>，在<code>Preferences | Languages &amp; Frameworks</code> - <code>Dart</code>里更换<code>Dart</code>的SDK地址</li><li>升级三方库的版本</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter难点解析</title>
    <link href="/2023/11/02/Flutter%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/11/02/Flutter%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-跨页面更新数据"><a href="#1-跨页面更新数据" class="headerlink" title="1.跨页面更新数据"></a>1.跨页面更新数据</h2><p>在使用<code>GetX</code>的时候，有时候需要跨页面修改数据，比如有ABC三个页面，在<code>C</code>页面的某个值更改值时，需要在<code>A</code>页面体现出来，这时候就需要用到<code>Get.find&lt;SomeController&gt;();</code>。</p><p>但是如果<code>SomeController</code>没有注册，也就是没有调用<code>Get.put()</code>方法，就会发生<code>Crash</code>。这时候，我们需要判断<code>SomeController</code>是否注册过：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">bool</span> isControllerRegistered = GetInstance().isRegistered&lt;SomeController&gt;();<br><span class="hljs-keyword">if</span> (isControllerRegistered) &#123;<br>    SomeController controller = Get.find&lt;SomeController&gt;();<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-onInit不调用的问题"><a href="#2-onInit不调用的问题" class="headerlink" title="2.onInit不调用的问题"></a>2.onInit不调用的问题</h2><p>使用<code>GetX</code>的时候，有时候<code>controller</code>的<code>onInit</code>方法不调用，原因很可能是在<code>view</code>中没有调用<code>controller</code>的方法，<code>controller</code>没有加载的缘故</p><h2 id="3-TabBar的问题"><a href="#3-TabBar的问题" class="headerlink" title="3.TabBar的问题"></a>3.TabBar的问题</h2><p>如果使用<code>PageView</code>配合<code>BottomNavigationBarItem</code>，在进入App的时候，所有Page都会加载，有些时候这样做会产生问题。(比如b需要a的一些数据，但是b已经加载完成了，a的数据还没请求成功)。<br>所有最好是使用下列示例代码（不使用Pageview）：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart">Scaffold(<br>    appBar: appbar,<br>    body: pages[currentIndex],<br>    bottomNavigationBar: BottomNavigationBar(<br>        items: [<br>            item1,<br>            item2,<br>            ...<br>        ]<br>    )<br>);<br></code></pre></td></tr></table></figure><h2 id="4-Text组件显示红色字体，带有黄色下划线"><a href="#4-Text组件显示红色字体，带有黄色下划线" class="headerlink" title="4.Text组件显示红色字体，带有黄色下划线"></a>4.Text组件显示红色字体，带有黄色下划线</h2><p>这是因为该<code>Widget</code>没有被<code>Scaffold</code>、<code>Dialog</code>等包裹，因为这些组件内置<code>DefaultTextStyle</code>，如果你不想使用上述组件，也可以手动使用<code>DefaultTextStyle</code>包裹，这样<code>Text</code>就显示正常了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Flutter的WebRTC学习</title>
    <link href="/2023/10/31/%E5%9F%BA%E4%BA%8EFlutter%E7%9A%84WebRTC%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/10/31/%E5%9F%BA%E4%BA%8EFlutter%E7%9A%84WebRTC%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基于Flutter的WebRTC学习"><a href="#基于Flutter的WebRTC学习" class="headerlink" title="基于Flutter的WebRTC学习"></a>基于Flutter的WebRTC学习</h1><p>学习WebRTC之前，先需要了解几个名词：</p><p>信令服务器：<br>是用来交换数据的，例如交换<code>SDP</code>等。<br>信令服务器的协议由多种方式，最常用的是<code>XHR</code>和<code>WebSocket</code>进行数据交换</p><p>SDP:<br>Session Discription Protocol(会话描述协议)<br>双方进行媒体协商(也就是<strong>交换SDP</strong>)的时候使用(例如：双方使用的音视频编码格式等等)<br>通过<strong>信令服务器</strong>进行传输</p><p>Candidate:<br>网络信息，通过<strong>信令服务器</strong>进行交换</p><p>ICE:<br>是一种框架，使各种NAT穿透技术可以实现统一，该技术可以让客户端成功地穿透远程用户与网络之间可能存在的各类防火墙。</p><p>Stun服务器：<br>STUN服务器能够知道Peer-A以及Peer-B的公网IP地址及端口</p><p>WebRTC主要流程分为三个部分：</p><ol><li>媒体协商<br>Peer-A和PeerB通过<strong>信令服务器</strong>进行媒体协商，双方交换的数据由<strong>SDP</strong>描述</li><li>网络协商<br>Peer-A和PeerB通过<strong>Stun服务器</strong>获取到各自的网络信息(如：IP，端口等)，然后通过<strong>信令服务器</strong>转发</li><li>建立连接<br>如果没有直连，那就通过<strong>TURN中转服务器</strong>进行转发音视频数据, 最终完成视频通话</li></ol><h4 id="WebRTC代码部分的流程"><a href="#WebRTC代码部分的流程" class="headerlink" title="WebRTC代码部分的流程"></a>WebRTC代码部分的流程</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">RTCVideoRenderer _localRenderer = RTCVideoRenderer(); <span class="hljs-comment">//本地流渲染</span><br>RTCVideoRenderer _remoteRenderer = RTCVideoRenderer(); <span class="hljs-comment">//远程流渲染</span><br>MediaStream? _localStream; <span class="hljs-comment">//本地流</span><br></code></pre></td></tr></table></figure><h5 id="1-获取媒体流"><a href="#1-获取媒体流" class="headerlink" title="1.获取媒体流"></a>1.获取媒体流</h5><p>使用 <code>getUserMedia</code>获取媒体流，返回一个<code>stream</code>对象，可以用<code>RTCVideoRenderer</code>来进行渲染。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">navigator<br>    .mediaDevices<br>    .getUserMedia(P2PConstraints.MEDIA_CONSTRAINTS)<br>    .then(stream) &#123;<br>        _localStream = stream;<br>        <span class="hljs-comment">//渲染本地流</span><br>        setState(() &#123;<br>          _localRenderer.srcObject = stream;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="2-生成pc对象"><a href="#2-生成pc对象" class="headerlink" title="2.生成pc对象"></a>2.生成pc对象</h5><p><code>pc</code>对象其实就是是<code>RTCPeerConnection</code>对象，该类是最主要的<code>WebRTC</code>类，负责建立<code>WebRTC</code>连接，处理音视频数据流的传输</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">RTCPeerConnection? pc;<br>pc = <span class="hljs-keyword">await</span> createPeerConnection(P2PConstraints.PC_CONSTRAINTS);<br></code></pre></td></tr></table></figure><h5 id="3-将stream添加到peer-A对象"><a href="#3-将stream添加到peer-A对象" class="headerlink" title="3. 将stream添加到peer-A对象"></a>3. 将<code>stream</code>添加到peer-A对象</h5><p>将<code>第1步</code>获取到的<code>stream</code>添加到<code>peer-A</code>对象</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">_localStream!.getTracks().forEach((track) &#123;<br>    pc!.addTrack(track, _localStream!);<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="4-peer-A创建offer"><a href="#4-peer-A创建offer" class="headerlink" title="4.peer-A创建offer"></a>4.peer-A创建<code>offer</code></h5><p>创建<code>offer</code>会返回一个<code>RTCSessionDescription</code>对象，也就是<code>sdp</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">RTCSessionDescription sdp =<br>          <span class="hljs-keyword">await</span> pc!.createOffer(P2PConstraints.SDP_CONSTRAINTS);<br></code></pre></td></tr></table></figure><h5 id="5-设置本地描述"><a href="#5-设置本地描述" class="headerlink" title="5.设置本地描述"></a>5.设置本地描述</h5><p>设置本地描述<br>调用<code>setLocalDescription</code>方法后，会触发<code>pc</code>的<code>iceCandidate</code>方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">await</span> pc!.setLocalDescription(sdp);<br></code></pre></td></tr></table></figure><h5 id="6-将peer-A的sdp通过信令服务器发送给peer-B"><a href="#6-将peer-A的sdp通过信令服务器发送给peer-B" class="headerlink" title="6.将peer-A的sdp通过信令服务器发送给peer-B"></a>6.将<code>peer-A</code>的<code>sdp</code>通过信令服务器发送给<code>peer-B</code></h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//这个是自己实现的方法，</span><br><span class="hljs-comment">//通过websocket 或者 XHR 发送sdp到远端(peer-B)</span><br><span class="hljs-keyword">await</span> sendOfferSdp(sdp);<br></code></pre></td></tr></table></figure><h5 id="7-收到远端sdp"><a href="#7-收到远端sdp" class="headerlink" title="7.收到远端sdp"></a>7.收到远端<code>sdp</code></h5><p>根据信令服务器返回的信息，获取远端的<code>sdp</code>信息</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">RTCSessionDescription answerSdp =<br>          RTCSessionDescription(sdp, type);<br></code></pre></td></tr></table></figure><h5 id="8-设置远端描述"><a href="#8-设置远端描述" class="headerlink" title="8.设置远端描述"></a>8.设置远端描述</h5><p>至此，我们实现了交换<code>sdp</code>信息</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">pc!.setRemoteDescription(answerSdp);<br></code></pre></td></tr></table></figure><h5 id="9-交换ice地址信息"><a href="#9-交换ice地址信息" class="headerlink" title="9.交换ice地址信息"></a>9.交换ice地址信息</h5><p>在<code>第2步</code>中生成创建<code>pc</code>后，实现监听<code>onIceCandidate</code>，<code>第5步</code>以后会自动调用此方法，获取<code>candidate</code>信息</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">pc!.onIceCandidate = (candidate) &#123;<br>    <span class="hljs-comment">//发送candidate，自己实现的方法，通过信令服务器发送candidate</span><br>    sendCandidate(candidate);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Flutter,WebRTC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Runtime应用(1)-全局修改字体</title>
    <link href="/2018/11/01/Runtime%E5%BA%94%E7%94%A8-1-%E5%85%A8%E5%B1%80%E4%BF%AE%E6%94%B9%E5%AD%97%E4%BD%93/"/>
    <url>/2018/11/01/Runtime%E5%BA%94%E7%94%A8-1-%E5%85%A8%E5%B1%80%E4%BF%AE%E6%94%B9%E5%AD%97%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h4 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h4><p>我们首先来说下一般情况下更换字体的步骤:</p><ol><li><p>我们从网上down下来一个ttf格式的字体，拖入到项目中，如图所示</p><img src="/img/Runtime01/runtime_01.png"></li><li><p>在info.plist文件中添加<code>Fonts provided by application</code>，<code>item</code>写上文件名，我这里是<code>蔡云汉隶书书法字体.ttf</code>。这时候需要检查一下<code>Build Phases</code> –&gt; <code>Copy Bundle Resources</code>里面有没有我们拖进去的文件。如果没有，把它Add进去。</p><img src="/img/Runtime01/runtime_02.png">但是，我们现在还不能使用，因为我们需要找到这个字体的`PostScript`名称那到底要怎么找呢？我们先在电脑上安装这个字体，这时候会在字体册看到它，然后如图操作就可以了。<img src="/img/Runtime01/runtime_03.png"></li><li><p>最后我们在项目中使用如下代码，就可以看到效果了</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objc">label.font = [<span class="hljs-built_in">UIFont</span> fontWithName:<span class="hljs-string">@&quot;CaiYunHanMaoBi-LiShu&quot;</span> size:<span class="hljs-number">11</span>];<br></code></pre></td></tr></table></figure></li></ol><h4 id="Runtime更换全局字体"><a href="#Runtime更换全局字体" class="headerlink" title="Runtime更换全局字体"></a>Runtime更换全局字体</h4><p>上面只是简单回顾了一下更换字体的步骤，如果我们在开发过程中，每次更换字体都这样，未免有点麻烦。如果说我们项目已经完成了，老板突然来一句，嗯，苹果字体太丑了，我们换个字体，你是不是要哭晕在厕所了。<br>下面就祭出我们的大杀器 – <code>Runtime</code>。</p><h5 id="移花接木"><a href="#移花接木" class="headerlink" title="移花接木"></a>移花接木</h5><p>我们想到每次更换字体都会调<code>systemFontOfSize:</code>方法，那么是不是只要我们交换这个方法，在方法里面换成我们自己的字体不就行了吗。说干就干。我们添加一个<code>UIFont</code>的分类<code>XX</code></p>   <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-string">&quot;UIFont+XX.h&quot;</span></span><br>    <br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">UIFont</span> (<span class="hljs-title">XX</span>)</span><br>    <br>+ (<span class="hljs-type">void</span>)load &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>  <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>      Method systemMethod = class_getClassMethod([<span class="hljs-built_in">UIFont</span> <span class="hljs-keyword">class</span>], <span class="hljs-keyword">@selector</span>(systemFontOfSize:));<br>      Method swizzMethod = class_getClassMethod([<span class="hljs-built_in">UIFont</span> <span class="hljs-keyword">class</span>], <span class="hljs-keyword">@selector</span>(my_systemFontOfSize:));<br>      method_exchangeImplementations(systemMethod, swizzMethod);<br>  &#125;);<br>&#125;<br>    <br>+ (<span class="hljs-built_in">UIFont</span> *)my_systemFontOfSize:(<span class="hljs-built_in">CGFloat</span>)size &#123;<br>    [<span class="hljs-built_in">UIFont</span> my_systemFontOfSize:size];<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">UIFont</span> fontWithName:<span class="hljs-string">@&quot;CaiYunHanMaoBi-LiShu&quot;</span> size:size];<br>&#125;<br></code></pre></td></tr></table></figure><p>然后运行查看效果<br><img src="/img/Runtime01/runtime_04.GIF"></p><p>我们发现，还有很大一部分控件的字体是没有改变的。是不是有好多控件是不会调用<code>systemFontOfSize:</code>方法的。那怎么办？</p><h5 id="偷天换柱"><a href="#偷天换柱" class="headerlink" title="偷天换柱"></a>偷天换柱</h5><p>兵来将挡，水来土掩，袖子一撸就是干。一般情况下，显示<code>text</code>的控件只有一个，就是<code>UILabel</code>。就算是什么<code>UIButton</code>，<code>UITextField</code>的用于显示<code>Text</code>的子控件，也是继承于<code>UILabel</code>。想到这点，我们就去打<code>UILabel</code>的主意，只要我们改变所有的<code>UILabel</code>的字体不就可以了吗？<br>那么，我们要交换哪个方法呢？</p><p>答案是: <code>willMoveToSuperview:</code>。<br>看方法名我们知道，这个方法会在控件将要加载到父view上时调用，这时候控件的各种属性基本已经确定了，我们就可以偷偷得修改了。</p>   <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-string">&quot;UILabel+FontChange.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CustomFontName @<span class="hljs-string">&quot;CaiYunHanMaoBi-LiShu&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">UILabel</span> (<span class="hljs-title">FontChange</span>)</span><br><br>+ (<span class="hljs-type">void</span>)load &#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>   <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>       SEL systemSel = <span class="hljs-keyword">@selector</span>(willMoveToSuperview:);<br>       SEL swizzSel = <span class="hljs-keyword">@selector</span>(myWillMoveToSuperview:);<br>       Method systemMethod = class_getInstanceMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], systemSel);<br>       Method swizzMethod = class_getInstanceMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], swizzSel);<br>   &#125;);<br>   method_exchangeImplementations(systemMethod, swizzMethod);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)myWillMoveToSuperview:(<span class="hljs-built_in">UIView</span> *)newSuperview &#123;<br>   <span class="hljs-keyword">self</span>.font = [<span class="hljs-built_in">UIFont</span> fontWithName:<span class="hljs-string">@&quot;CaiYunHanMaoBi-LiShu&quot;</span> size:<span class="hljs-keyword">self</span>.font.pointSize];<br>   [<span class="hljs-keyword">self</span> myWillMoveToSuperview:newSuperview];<br>&#125;<br></code></pre></td></tr></table></figure><p>然后运行项目。WTF，居然崩溃了，崩溃信息如下：</p>   <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objc">-[_UIWebViewScrollView font]: unrecognized selector sent to instance <span class="hljs-number">0x10c810a00</span><br><span class="hljs-number">2018</span><span class="hljs-number">-11</span><span class="hljs-number">-01</span> <span class="hljs-number">17</span>:<span class="hljs-number">05</span>:<span class="hljs-number">23.843594</span>+<span class="hljs-number">0800</span> AnXinCaiFu_XSD[<span class="hljs-number">18446</span>:<span class="hljs-number">4169433</span>] *** Terminating app due to uncaught exception <span class="hljs-string">&#x27;NSInvalidArgumentException&#x27;</span>, reason: <span class="hljs-string">&#x27;-[_UIWebViewScrollView font]: unrecognized selector sent to instance 0x10c810a00&#x27;</span><br></code></pre></td></tr></table></figure><p>崩溃的主要原因是<code>_UIWebViewScrollView</code>没有<code>getFont</code>这个方法（它当然没有）。那么为什么它会调到<code>getFont</code>方法呢？我们写的是<code>UIFont</code>的分类，<code>self.font</code>应该调用的是<code>UILabel</code>的<code>getFont</code>方法呀？</p><p>答案当然是因为消息转发，由于UIFont没有实现<code>willMoveToSuperview:</code>方法，然后就被转发到<code>_UIWebViewScrollView</code>那里了，但是它并没有<code>getFont</code>方法，所以就Crash了。（可以参考iOS的消息转发机制），这里不细说（细说我也不会啊😂）。</p><p>那怎么解决呢？很简单，判断一下就好了：</p>   <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 我们在这里使用class_addMethod()函数对Method Swizzling做了一层验证，</span><br><span class="hljs-comment"> 如果self没有实现被交换的方法，会导致失败。</span><br><span class="hljs-comment"> 而且self没有交换的方法实现，但是父类有这个方法，这样就会调用父类的方法，结果就不是我们想要的结果了。</span><br><span class="hljs-comment"> 所以我们在这里通过class_addMethod()的验证，如果self实现了这个方法，class_addMethod()函数将会返回 NO，我们就可以对其进行交换了。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">BOOL</span> isAdd = class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], systemSel, method_getImplementation(swizzMethod), method_getTypeEncoding(swizzMethod));<br><span class="hljs-keyword">if</span> (isAdd) &#123;<br>    class_replaceMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], swizzSel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//否则，交换两个方法的实现</span><br>    method_exchangeImplementations(systemMethod, swizzMethod);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我再一次运行项目，基本上是接近完美了。<br><img src="/img/Runtime01/runtime_05.jpeg"></p><p>但是我们发现Tabbar的字体还是顽固的没有变化😓。<strong>有可能是因为在它加载到父View上之后再次改变了字体</strong></p><h5 id="幻影移形"><a href="#幻影移形" class="headerlink" title="幻影移形"></a>幻影移形</h5><p>我们再想，每次UILabel设置字体是不是要调<code>setFont</code>方法，就像上面说的，那么我们就交换它的<code>setFont</code>方法，让它设置字体的时候偷偷调换掉它的字体。</p>   <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//交换Set方法</span><br>SEL sysSetFont = <span class="hljs-keyword">@selector</span>(setFont:);<br>SEL swizzSetFont = <span class="hljs-keyword">@selector</span>(mySetFont:);<br><br>Method sysSetFontMethod = class_getInstanceMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], sysSetFont);<br>Method swizzSetFontMethod = class_getInstanceMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], swizzSetFont);<br><br>method_exchangeImplementations(sysSetFontMethod, swizzSetFontMethod);<br>  <br>- (<span class="hljs-type">void</span>)mySetFont:(<span class="hljs-built_in">UIFont</span> *)font &#123;<br>  <span class="hljs-built_in">UIFont</span> *swizzFont = [<span class="hljs-built_in">UIFont</span> fontWithName:CustomFontName size:font.pointSize];<br>  [<span class="hljs-keyword">self</span> mySetFont:swizzFont];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>至此，我们终于完成了全局更换字体，虽然代码不多，但是也耗费了我们一段时间，这其中思想重于代码。<br>我们要实现什么效果，怎么做才能实现我们的目的，这其中会造成什么样的后果，或者为什么没有实现我们想要的效果。这是我们要思考的问题，这些为什么，也就是促进我们继续学习的动力。</p><p>示例代码我放在Github上了，地址：<a href="https://github.com/Shalliy/changeFont.git">https://github.com/Shalliy/changeFont.git</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决“Pod install”慢的问题</title>
    <link href="/2018/09/04/%E8%A7%A3%E5%86%B3%E2%80%98%20Pod%20install%20%E2%80%99%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2018/09/04/%E8%A7%A3%E5%86%B3%E2%80%98%20Pod%20install%20%E2%80%99%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>前段时间使用cocopods安装百度地图的SDK，发现失败了</p><img src="/img/PodInstall/BEEABCAD3116C15F85755B6933808675.jpg" width="50%"><span id="more"></span><p>直到我看到了看了这么一篇博客：<br><a href="https://blog.csdn.net/wuquan0625/article/details/47401235">pod install速度慢的终极解决方案 - CSDN博客</a></p><p>现在简单记录一下：<br>其实真正的原因不是Pod命令，而是在于Github上代码库访问速度变慢，那么我们终极的解决办法就是加快Git命令的速度。        </p><p>那么怎么才能加快Git命令的速度呢，当然是<code>科学上网</code>了🤫。<br>我用的是Shadowsocks-NG-R8，具体怎么使用，大家可以自行百度。</p><p>打开<code>Shadowsocks</code> - <code>高级设置</code>选项，可以看到下图所示：</p><img src="/img/PodInstall/WX20180904-135254@2x.png" width="50%"><p>红框所示圈出来的就是下面我们需要用到的。<br><strong>接下来我们输入命令：</strong><br><code>git config --global http.proxy socks5://127.0.0.1:1086</code></p><p>如果我们不希望国内Git库也走代理（我觉得还是全局好，国内库也有特别慢的），可以输入命令：<br><code>git config --global http.https://github.com.proxy socks5://127.0.0.1:1086</code></p><p><strong>当然，如果要恢复&#x2F;移除上面设置的Git代理</strong><br><code>git config --global --unset http.proxy</code><br><code>git config --global --unset http.https://github.com.proxy</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View的Layout方法粗解</title>
    <link href="/2018/08/28/View%E7%9A%84Layout%E6%96%B9%E6%B3%95%E7%B2%97%E8%A7%A3/"/>
    <url>/2018/08/28/View%E7%9A%84Layout%E6%96%B9%E6%B3%95%E7%B2%97%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>参考链接：<a href="https://www.jianshu.com/p/2ef48c2f0c97">https://www.jianshu.com/p/2ef48c2f0c97</a></p><pre><code class="hljs">View的Layout方法主要有以下几种：    layoutSubviews    layoutIfNeeded    setNeedsLayout    setNeedsDisplay    drawRect    sizeThatFits    sizeToFit       </code></pre><span id="more"></span><h4 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h4><ul><li><code>layoutSubviews</code>方法不能手动调用，需要调用<code>[self setNeedsLayout]</code>来触发。</li><li><code>drawRect</code>也不能手动调用，需要调用<code>[self setNeedsDisplay]</code>来触发。</li><li>最后剩下<code>layoutIfNeeded</code>方法。这个方法在使用约束的时候调用，**可以立即更新效果(立即刷新)**。(例如：autoLayout 跟 frame 混用)<code>setNeedsLayout</code>不会立即刷新。</li><li><code>sizeThatFits:</code>会计算出最优的size，并返回给你，但是view本身并不会改变size。</li><li><code>sizeToFit</code>会计算出最优size，并且改变view自身的size</li></ul><ol><li><p><code>layoutSubviews</code>调用时机（系统调用）<br>直接调用<code>[self setNeedsLayout];</code> 。<br><code>initWithframe:</code>如果初始<code>frame</code>为<code>CGRectZero</code>则不调用，否则调用<br><code>addSubview</code>的时候。<br><code>view</code> 的 <code>size</code>发生改变的时候，<strong>前提是<code>frame</code>的值设置前后发生变化</strong>。<br>滑动<code>UIScrollView</code>的时候。<br>旋转<code>Screen</code>会触发父<code>View</code>上的<code>layoutSubviews</code>事件**(待验证，作者说验证过没有触发)</p></li><li><p><code>setNeedsDisplay</code>调用时机<br>该方法在调用时，会自动调用<code>drawRect</code>方法。<code>drawRect</code>方法主要用来画图。<br>so：<br>当需要刷新布局时，用<code>setNeedsLayOut</code>方法；<br>当需要重新绘画时，调用<code>setNeedsDisplay</code>方法。</p></li></ol><h4 id="粗浅的总结"><a href="#粗浅的总结" class="headerlink" title="粗浅的总结"></a>粗浅的总结</h4><p>总的来说：我们可以重写父类的<code>layoutSubviews</code> 和 <code>drawRect</code> 方法，但是我们不能手动调用它们，而是需要分别调用<code>setNeedsLayout</code> 和 <code>setNeedsDisplay</code>这两个方法来触发。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS内购（IAP）那些事</title>
    <link href="/2018/07/31/iOS%E5%86%85%E8%B4%AD%EF%BC%88IAP%EF%BC%89%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2018/07/31/iOS%E5%86%85%E8%B4%AD%EF%BC%88IAP%EF%BC%89%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>最近有个项目客户总是反应掉单，于是乎就看了看内购相关的东西，发现坑还真是不少，这里做个总结。</p><blockquote><p>IAP，即in-App Purchase，是一种智能移动终端应用程序付费的模式，在苹果（Apple）iOS、谷歌安卓（Google Android）、微软WindowsPhone等智能移动终端操作系统中都有相应的实现。<br>– 百度百科</p></blockquote><span id="more"></span><h3 id="内购流程"><a href="#内购流程" class="headerlink" title="内购流程"></a>内购流程</h3><p>想知道坑在哪里，首先应该了解流程，那么我们首先通过内购的流程，一步步地说坑到底在哪里。<br>苹果内购的主要流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs flow">获取商品信息 =&gt; 创建交易 =&gt; 把交易添加到队列 =&gt; 交易成功获取凭证 <br>=&gt; 拿着凭证做二次验证 =&gt; 交易成功<br></code></pre></td></tr></table></figure><ol><li><p>通过产品ID获取商品信息（SKProduct）。</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-string">&lt;StoreKit/StoreKit.h&gt;</span></span><br><br><span class="hljs-comment">//把商品ID信息放入一个集合中</span><br><span class="hljs-built_in">NSSet</span> *sets = [<span class="hljs-built_in">NSSet</span> setWithObjects:<span class="hljs-string">@&quot;phonicsphase1&quot;</span>, <span class="hljs-literal">nil</span>];<br><span class="hljs-comment">//请求内购商品信息，只返回你请求的产品（主要用于验证商品的有效性）</span><br><span class="hljs-built_in">SKProductsRequest</span> *productrequest = [[<span class="hljs-built_in">SKProductsRequest</span> alloc] initWithProductIdentifiers:sets];<br>productrequest.delegate = <span class="hljs-keyword">self</span>;<br>[productrequest start];<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - 获取商品ID成功的代理方法</span><br>- (<span class="hljs-type">void</span>)productsRequest:(<span class="hljs-built_in">SKProductsRequest</span> *)request didReceiveResponse:(<span class="hljs-built_in">SKProductsResponse</span> *)response &#123;<br>    <span class="hljs-comment">//返回的是SKProduct对象数组</span><br>    <span class="hljs-comment">//如果你上面请求的是多个，那么这里返回的也是多个</span><br>    <span class="hljs-built_in">SKProduct</span> *product = [response.products firstObject];<br>    <span class="hljs-comment">//查询成功，开始支付</span><br>    [<span class="hljs-keyword">self</span> startPaymentWithProduct:product];<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>拿到商品信息，创建支付对象<code>SKMutablePayment</code>。</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)startPaymentWithProduct:(<span class="hljs-built_in">SKProduct</span> *)product &#123;<br>    <span class="hljs-built_in">SKMutablePayment</span> *payment = [<span class="hljs-built_in">SKMutablePayment</span> paymentWithProduct:product];<br>    payment.applicationUsername = <span class="hljs-string">@&quot;myOrderID&quot;</span>;<br>    [[<span class="hljs-built_in">SKPaymentQueue</span> defaultQueue] addPayment:payment];<br>&#125;<br></code></pre></td></tr></table></figure><p> 这里的<code>applicationUsername</code>是一个透传字段，我们在这里传什么参数，在支付成功的时候Apple会原封不动的返回给我们。最常用的就是拿它传递我们自己的订单号，以便跟我们知道是哪个订单支付成功了。<br> <strong>这里有个坑：</strong><br> 据说我们传递过去的<code>applicationUsername</code>有可能返回的时候变成空的，这点我没有遇到，有遇到的可以说一下。</p></li><li><p>把当前交易添加到交易队列中去（上面的addPayment:方法）。</p></li><li><p>监听支付结果（paymentQueue:updatedTransactions:），如果支付成功，Apple会把支付成功的凭证（recipt）存到沙盒中。</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//首先我们要在 viewDidLoad 方法中添加监听对象 </span><br>[[<span class="hljs-built_in">SKPaymentQueue</span> defaultQueue] addTransactionObserver:<span class="hljs-keyword">self</span>];<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -  监听的代理方法</span><br>- (<span class="hljs-type">void</span>)paymentQueue:(<span class="hljs-built_in">SKPaymentQueue</span> *)queue updatedTransactions:(<span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">SKPaymentTransaction</span> *&gt; *)transactions &#123;<br>        [transactions enumerateObjectsUsingBlock:^(<span class="hljs-built_in">SKPaymentTransaction</span> * _Nonnull obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-type">BOOL</span> * _Nonnull stop) &#123;<br>        <span class="hljs-built_in">SKPaymentTransaction</span> *transation = obj;<br>        <span class="hljs-keyword">switch</span> (transation.transactionState) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-built_in">SKPaymentTransactionStatePurchasing</span>:<br>                &#123;<br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;购买中&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>                <br>            <span class="hljs-keyword">case</span> <span class="hljs-built_in">SKPaymentTransactionStatePurchased</span>:<br>            &#123;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;交易完成&quot;</span>);<br>                <span class="hljs-comment">//获取透传字段</span><br>                <span class="hljs-built_in">NSString</span> *orderNo = transation.payment.applicationUsername;<br>                <span class="hljs-comment">//transactionIdentifier：相当于Apple的订单号</span><br>                <span class="hljs-built_in">NSString</span> *transationId = transation.transactionIdentifier;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;orderNo = %@, 交易ID = %@&quot;</span>, orderNo, transationId);<br>                <span class="hljs-comment">//从沙盒中获取交易凭证</span><br>                <span class="hljs-built_in">NSData</span> *reciptData = [<span class="hljs-built_in">NSData</span> dataWithContentsOfURL:[[<span class="hljs-built_in">NSBundle</span> mainBundle] appStoreReceiptURL]];<br>                <span class="hljs-comment">//转化成Base64字符串（用于校验）</span><br>                <span class="hljs-built_in">NSString</span> *reciptString = [reciptData base64EncodedStringWithOptions:<span class="hljs-built_in">NSDataBase64Encoding64CharacterLineLength</span>];<br>                <span class="hljs-comment">//传给后台做二次验证</span><br>                [<span class="hljs-keyword">self</span> checkReceipt:reciptString];                <br>            &#125;<br>                <span class="hljs-keyword">break</span>;<br>                <br>            <span class="hljs-keyword">case</span> <span class="hljs-built_in">SKPaymentTransactionStateFailed</span>:<br>            &#123;<br>                <span class="hljs-comment">//localizedDescription可以作为提示信息（交易失败无法连接到 iTunes Store）</span><br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;交易失败%@&quot;</span>, transation.error.localizedDescription);<br>                [[<span class="hljs-built_in">SKPaymentQueue</span> defaultQueue] finishTransaction:transation];<br>            &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <br>            <span class="hljs-keyword">case</span> <span class="hljs-built_in">SKPaymentTransactionStateRestored</span>:<br>            &#123;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;恢复购买完成&quot;</span>);<br>                <span class="hljs-comment">//恢复完成（对应restoreCompletedTransactions）方法</span><br>            &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <br>            <span class="hljs-keyword">case</span> <span class="hljs-built_in">SKPaymentTransactionStateDeferred</span>:<br>            &#123;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;交易推迟, 等待外部操作&quot;</span>);<br>                <span class="hljs-comment">//交易推迟</span><br>                <span class="hljs-comment">//官方解释是：交易已经加入队列，但是需要等待外部操作</span><br>                <span class="hljs-comment">//主要用于儿童模式，需要询问家长同意。这种情况下不能关闭订单（完成交易），否则这类充值将无法处理。                </span><br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>                <br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>注意：</strong></p><ol><li>透传字段<code>applicationUsername</code>可能返回的是<code>nil</code>，这也是丢单的原因之一，有些人说遇到过，有的则说没有遇到过。这个尚不清楚。</li><li><code>[[SKPaymentQueue defaultQueue] finishTransaction:transation]</code>如果不调用这个方法，那么<code>transation</code>就永远不会结束。也就是说每次进来都会重新调用<code>updatedTransactions</code>这个方法，<strong>就算你做过二次校验都没用</strong>。</li><li>二次校验只会校验你的凭证是不是有效，不会关心你这个凭证是不是校验过了，所以说，<strong>一个凭证可以被校验多次（这是刷单方法之一）</strong></li><li>上面说过，如果不<code>finishTransaction</code>，每次进入这个界面都会调用监听方法，但是注意了<strong>每次返回的 reciptData都是不一样，即使是同一个订单。</strong>也就是说，同一个订单也有可能有多个<code>reciptData</code>，所以它并不能用来确定是哪个订单。</li><li>我们最好是在App启动的时候就去设置监听。把内购封装成一个工具类，这样每次启动App就会调用苹果的补单流程。</li></ol></li><li><p>我们从沙盒中取到凭证（recipt），发送给我们自己后台进行二次验证，验证成功表示支付成功。</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)checkReceipt:(<span class="hljs-built_in">NSString</span> *)receipt &#123;<br>    [AntManager postWithPath:CheckReceipt_URL params:params success:^(<span class="hljs-type">id</span> response) &#123;<br>        <span class="hljs-keyword">if</span> ([response[<span class="hljs-string">@&quot;status&quot;</span>] integerValue] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果支付成功，我们就结束交易</span><br>            [[<span class="hljs-built_in">SKPaymentQueue</span> defaultQueue] finishTransaction:transation]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <br>        &#125;<br>    &#125; failure:^(<span class="hljs-type">id</span> error) &#123;<br>    <br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>注意：</strong><br> 前面说过，Apple在最初设计IAP的时候就没有想过后台的参与，但是，为了安全起见，我们要把二次验证放到后台做，至于为什么，我们后边会讲到。但是不管怎样，我们至少要了解一下怎么做的二次校验。</p><ul><li>我们把recipt经过Base64编码之后，传给Apple的验证服务器进行验证。<br> 格式如下:<br> <code>&#123;&quot;receipt-data&quot;: 你编码过的recipt&#125;</code></li><li>Apple的验证服务器地址有两个<br> <code>https://sandbox.itunes.apple.com/verifyReceipt</code> 是沙盒环境的验证地址。<br> <code>https://buy.itunes.apple.com/verifyReceipt</code> 是正式环境的验证地址</li><li>如果你用的是测试账号（就是在iTunes Connect里面设置的，具体请<a href="https://help.apple.com/app-store-connect/#/dev8b997bee1">看这里</a>）支付的，那么你就需要发送到沙盒环境的验证地址，正式环境应该切换到正式环境的验证地址。</li></ul></li></ol><p>Apple返回的完整数据如下：</p><pre><code class="hljs"><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Sandbox&quot;</span><br><span class="hljs-attr">&quot;receipt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;receipt_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ProductionSandbox&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;adam_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;app_item_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;bundle_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.BlueMobi.Phonics&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;application_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.5.0&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;download_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;version_external_identifier&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;receipt_creation_date&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018-06-28 14:08:26 Etc/GMT&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;receipt_creation_date_ms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1530194906000&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;receipt_creation_date_pst&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018-06-28 07:08:26 America/Los_Angeles&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;request_date&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018-08-05 04:50:58 Etc/GMT&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;request_date_ms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1533444658147&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;request_date_pst&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018-08-04 21:50:58 America/Los_Angeles&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;original_purchase_date&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2013-08-01 07:00:00 Etc/GMT&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;original_purchase_date_ms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1375340400000&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;original_purchase_date_pst&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2013-08-01 00:00:00 America/Los_Angeles&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;original_application_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;in_app&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>       <span class="hljs-punctuation">&#123;</span><br>           <span class="hljs-attr">&quot;quantity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;product_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*******&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;transaction_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1000000404314890&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//这个苹果的交易唯一标识符</span><br>           <span class="hljs-attr">&quot;original_transaction_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1000000404314890&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;purchase_date&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018-06-04 09:58:41 Etc/GMT&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;purchase_date_ms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1528106321000&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;purchase_date_pst&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018-06-04 02:58:41 America/Los_Angeles&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;original_purchase_date&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018-06-04 09:58:41 Etc/GMT&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;original_purchase_date_ms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1528106321000&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;original_purchase_date_pst&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018-06-04 02:58:41 America/Los_Angeles&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;is_trial_period&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;false&quot;</span><br>       <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>       <span class="hljs-punctuation">&#123;</span><br>           <span class="hljs-attr">&quot;quantity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;product_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*******&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;transaction_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1000000404523773&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;original_transaction_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1000000404523773&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;purchase_date&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018-06-05 02:21:26 Etc/GMT&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;purchase_date_ms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1528165286000&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;purchase_date_pst&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018-06-04 19:21:26 America/Los_Angeles&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;original_purchase_date&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018-06-05 02:21:26 Etc/GMT&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;original_purchase_date_ms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1528165286000&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;original_purchase_date_pst&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018-06-04 19:21:26 America/Los_Angeles&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;is_trial_period&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;false&quot;</span><br>       <span class="hljs-punctuation">&#125;</span><br>     <span class="hljs-punctuation">]</span><br>   <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>* Apple返回的数据也是Json格式的，里面有个字段`status`，当`status == 0`的时候，表示校验成功。但是，我们不能以这个`status`为标准，我们还要判断我们的订单是不是在校验信息里面。* 当`status`不为0的时候，是没有其余的Json数据的。    <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-number">21000</span>    App Store 不能读取你提供的JSON对象<br><span class="hljs-number">21002</span>    receipt-data 域的数据有问题<br><span class="hljs-number">21003</span>    receipt 无法通过验证<br><span class="hljs-number">21004</span>    提供的 shared secret 不匹配你账号中的 shared secret<br><span class="hljs-number">21005</span>    receipt 服务器当前不可用<br><span class="hljs-number">21006</span>    receipt 合法<span class="hljs-punctuation">,</span> 但是订阅已过期. 服务器接收到这个状态码时<span class="hljs-punctuation">,</span> receipt 数据仍然会解码并一起发送<br><span class="hljs-number">21007</span>    receipt 是 Sandbox receipt<span class="hljs-punctuation">,</span> 但却发送至生产系统的验证服务<br><span class="hljs-number">21008</span>    receipt 是生产 receipt<span class="hljs-punctuation">,</span> 但却发送至 Sandbox 环境的验证服务<br></code></pre></td></tr></table></figure>* `in_app`是一个数组，一条数据对应一条交易。后台需要遍历数组，跟我们传递给后台的`transaction_id`做对比，看看是否存在啊，如果存在就说明本条交易校验成功了。* 有人说`in_app`里面的数据是按照时间先后来排序的，只取第一条就可以了，但是经过我的测试发现并不是这样的，所以最好还是逐条对比。</code></pre><h3 id="掉单问题的探讨"><a href="#掉单问题的探讨" class="headerlink" title="掉单问题的探讨"></a>掉单问题的探讨</h3><p>苹果的IAP缺陷还是很明显的，但是没办法，谁让苹果一家独大呢，我们也只能吐吐槽，想尽一切办法防止掉单的发生。<br>掉单的原因是有多方面的，我们一个个来说。</p><ol><li><p>首先苹果是有补单措施的，如果不finish交易，每次都会请求<code>updatedTransactions:</code>方法的。但是前面说了，<code>applicationUsername</code>的缺失会导致掉单。<code>applicationUsername</code>的丢失会让我们丢失订单号，但是实际的支付仍然是成功的。</p><ol><li>可以传递给后台<code>未知订单</code>，但客户投诉的时候，我们从未知订单里面找到符合条件的给恢复订单信息（这样做显然效率很低）</li><li><strong>常用的做法是：</strong><ul><li>把每个订单的<code>recipt</code>、<code>orderNumber</code>、<code>userId</code>、<code>transactionIdentifier</code>等你需要的信息保存为一个plist文件，每个plist文件对应一个订单。等我们后台返回支付成功的时候就删除相应的plist。</li><li>每次启动App的时候去沙盒查找plist文件，如果有，就读取plist文件去请求服务器做二次验证，直到服务器返回成功为止。</li><li>但是这样做，就需要在<code>SKPaymentTransactionStatePurchased</code>的时候<code>finishTransaction:</code>结束交易，因为每次返回的<code>reciptData</code>是不同的。除非我们每次都去更新它。并且这样做的话，用户卸载App的时候，保存的订单信息全部都没有了。</li></ul></li><li>用户支付过后，没有等到验证，就更换Apple账号登录。这种情况我没有试过会不会调用<code>updatedTransactions:</code>方法</li><li>其实这个问题始终没有一个很好的解决方案，只能靠苹果的优化了。</li></ol></li><li><p>由于苹果的服务器在美帝，所以延迟的情况还是很严重的，这时候如果是请求超时，我们服务器又没有收到回调，那么就会产生掉单。比较坑的是，<code>updatedTransactions:</code><strong>在App整个生命周期只会走一次。</strong>其实这种情况只要重启App就会重新走苹果的补单流程了。大佬们如果觉得用户体验不好，可以把信息存本地，隔一段时间请求一次服务器。<br>其实现在掉单基本就是上面说的那个原因了，只要把它解决了，掉单基本上也就没有了。</p></li></ol><p><strong>注意：</strong></p><ol><li>掉单问题都是出现在支付完成之后，没有通过二次校验的时候。因为一旦我们得到了<code>recipt</code>，就说明苹果已经扣款成功了。但是为什么我们不能以这个作为支付成功的标准呢，请看下面的刷单系列。</li><li>针对上面第二种<code>recipt</code>存本地的方法，其实没有必要，苹果自己的补单措施基本上是够用了。</li><li>如果是你们的App中，用户可以一次性购买多个产品，那么更推荐把<code>recipt</code>存本地。因为如果在有多个成功交易未 finish 掉的情况下把应用关闭后再次打开的时候，有些交易的回调会被漏掉（苹果真坑啊！！！）。当然两者结合也是一个很好的办法。</li></ol><h3 id="刷单的问题"><a href="#刷单的问题" class="headerlink" title="刷单的问题"></a>刷单的问题</h3><p>刷单的转自<a href="https://blog.csdn.net/autfish/article/details/52682778">这篇博客</a><br>我在这里简述一下，做个小结。</p><p>刷单主要有以下几种方式：</p><ol><li>破解IAP</li><li>重复使用<code>recipt-data</code></li><li>信用卡黑卡</li><li>外币差价</li><li>以及苹果对小额消费不做验证规则的“36技术”</li></ol><p>我们这里只讨论 1 和 2 ，因为下面三种跟我们开发者没有关系，想要详细了解的可以去开头的博客上了解一下。</p><h4 id="1-破解IAP"><a href="#1-破解IAP" class="headerlink" title="1. 破解IAP"></a>1. 破解IAP</h4><p>   这个主要是我们不做二次验证引发的漏洞，非法用户可以利用插件模拟扣款成功，有可能是手动调用<code>updatedTransactions:</code>（我猜的😂）。就算是我们在App端做了二次验证，结果也有可能是被篡改过的。所以我们需要在自己的服务端进行二次验证。 <strong>任何在App端的数据都是不安全的！！！</strong></p><h4 id="2-重复使用recipt-data"><a href="#2-重复使用recipt-data" class="headerlink" title="2. 重复使用recipt-data"></a>2. 重复使用<code>recipt-data</code></h4><p>   我们直到，<code>recipt-data</code>是支付成功返回给我们的校验凭证，前面说过，苹果校验的时候只负责校验recipt的有效性和真假，并不负责这个凭证是否被用过。如果我们在后台只判断<code>status == 0</code>，而不去做其他判断的话，非法用户会保存<code>recipt-data</code>，然后多次使用，因为每次都是校验通过的。</p><p>   我们也不能判断<code>recipt-data</code>是否被使用，因为上面已经说过，同一个订单也会有多个<code>recipt-data</code>返回的。</p><p>   防范的方法是在确定status值为0后，进一步解析出数据中的transaction_id并存入数据库。每次发货前先检查数据库中是否已经有本次的transaction_id存在，如果已存在则拒绝发货。</p><p>还有一种情况需要注意，有些App购买前先有一步创建订单的行为，在服务器端记录购买的商品、时间等，且发货时是按照订单记录中的商品，那么需要比较苹果返回信息中的product_id与订单表中的记录值是否一致。</p><p>到了这里IAP基本上已经结束了，小弟只是把IAP的流程以及需要注意的点列出来，以上的方法只是作为总结，并不适用于所有状况，我们在开发中还要具体问题具体分析。希望大家开发中都不会掉单😄。</p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
